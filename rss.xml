<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Portfolio by Nicholas Pung]]></title><description><![CDATA[Learnings of a Web Developer]]></description><link>https://lumen.netlify.com</link><generator>RSS for Node</generator><lastBuildDate>Tue, 10 Sep 2019 15:28:42 GMT</lastBuildDate><item><title><![CDATA[Standalone Node API Server with Google OAuth | Part 2]]></title><description><![CDATA[After looking up documentation on how to best use Google OAuth, I've come to realize that majority of people writing online about Google OAuth use in applications that don't have a separate REST API. Therefore, they are able to use sessions in order to have users continue using the application while logged in. Or another solution would be to store the session data in the database, and having the client look up the database during the whole user interaction, which sounds less than ideal to me.]]></description><link>https://lumen.netlify.com/posts/struggling-with-google-oauth-2/</link><guid isPermaLink="false">https://lumen.netlify.com/posts/struggling-with-google-oauth-2/</guid><pubDate>Mon, 09 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;After looking up documentation on how to best use Google OAuth, I’ve come to realize that majority of people writing online about Google OAuth use in applications that don’t have a separate REST API. Therefore, they are able to use sessions in order to have users continue using the application while logged in. Or another solution would be to store the session data in the database, and having the client look up the database during the whole user interaction, which sounds less than ideal to me.&lt;/p&gt;
&lt;p&gt;Another thing I learned was that Express is unable to send anything over a response, unless it’s with cookies. Therefore, the only way that I would be able to use the application the way I wanted (sending over a JSON Web Token), was to send over a cookie.&lt;/p&gt;
&lt;h2 id=&quot;background&quot;&gt;&lt;a href=&quot;#background&quot; aria-label=&quot;background permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Background&lt;/h2&gt;
&lt;p&gt;Initially, while learning about the different ways to do user authentication, I came across 2 types of ways hackers breach through security: cross site scripting (XSS) and cross-site request forgery (CSRF) attacks. In terms understandable for me, XSS attacks are when malicious sites adds on a Javascript tag in order to target users of an application, rather than the application itself. CSRF attacks are when malicious sites pose as the application to intercept restricted data based on the user logged in.&lt;/p&gt;
&lt;p&gt;I hadn’t learned about these attacks when I first coded an user authentication application, thus I became scared about that possibility for an application that I would be using myself and storing about myself. Through research, what I found was that there are a few ways to mitigate CSRF attacks: only allowing POST requests to change data, sending a CSRF token attached to FORM fields and verifying them each time a POST request is made, and whitelisting websites in CORS. For XSS attacks: limit the time cookies are stored, deny all data being stored in HTML, and try not to use HTML elements that you are able to insert data into (e.g. contentEditable).&lt;/p&gt;
&lt;h2 id=&quot;solution&quot;&gt;&lt;a href=&quot;#solution&quot; aria-label=&quot;solution permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Solution&lt;/h2&gt;
&lt;p&gt;Because of those concerns, I tried long and hard to find a solution that would essentially be sending over a JSON Web Token through a request, and having the client-side store the token to access restricted routes. The solution I used was to create a JSON Web Token from Google OAuth, then sending over the token in the cookies, which disappears in an absurdly fast manner. So the client application will have the read the cookie stored on the webpage as soon as the redirect happens, and store the token into localStorage. Although it’s not the most ideal solution, it’s the solution that is the most simple to execute on, with a small timeline where hacks can happen.&lt;/p&gt;
&lt;p&gt;Resources:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://cheatsheetseries.owasp.org/cheatsheets/Cross&lt;em&gt;Site&lt;/em&gt;Scripting&lt;em&gt;Prevention&lt;/em&gt;Cheat_Sheet.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://www.owasp.org/index.php/Cross-site&lt;em&gt;Scripting&lt;/em&gt;(XSS)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://www.owasp.org/index.php/Cross-Site&lt;em&gt;Request&lt;/em&gt;Forgery_(CSRF)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Standalone Node API Server with Google OAuth | Part 1]]></title><description><![CDATA[For my personal project, I decided to develop a standalone Node API Server that would have Google OAuth for the login/register function. I had previously created a Node Server that was housed in the same repository as the React client with Google OAuth, so I didn't think that it would be that hard to separate the two. And boy was I wrong.]]></description><link>https://lumen.netlify.com/posts/struggling-with-google-oauth/</link><guid isPermaLink="false">https://lumen.netlify.com/posts/struggling-with-google-oauth/</guid><pubDate>Tue, 20 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;For my personal project, I decided to develop a standalone Node API Server that would have Google OAuth for the login/register function. I had previously created a Node Server that was housed in the same repository as the React client with Google OAuth, so I didn’t think that it would be that hard to separate the two. And boy was I wrong.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Development Environment
- client: http://localhost:3000
- server: http://localhost:7000&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In creating the standalone Node API Server and connecting it to my React client, I first ran into a CORS problem with Google OAuth in my development environment. I had to specify my local host address in the CORS middleware in order for the issue to bypass the CORS issue, stemming from the Google servers. &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;app.use(cors({ origin: &amp;#39;http://localhost:3000&amp;#39; })&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Afterwards, PassportJS explains that in order to access Google OAuth, you have to create a link in HTML in order to access it.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;a href=&amp;quot;http://localhost:7000/auth/google&amp;quot;&amp;gt;Sign In with Google&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This leads to the huge problem I had with PassportJS and Google OAuth.&lt;/p&gt;
&lt;p&gt;The way I structured my code, I used a NPM package called &lt;code class=&quot;language-text&quot;&gt;cookie-session&lt;/code&gt; to pass cookies as a session. However, the cookie is only stored on the server host. In this scenario, the cookie is stored in the server, rather than being passed to the client. This is where my previous experience failed me, since this wasn’t a problem with the server and client being housed on the same deployment.&lt;/p&gt;
&lt;p&gt;In order to understand how PassportJS does Google OAuth, I’ll walkthrough a scenario.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Access Google OAuth by clicking on &lt;code class=&quot;language-text&quot;&gt;http://localhost:7000/auth/google&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Triggers PassportJS Google OAuth function to check if user is in database&lt;/li&gt;
&lt;li&gt;When user is found, a cookie is created by &lt;code class=&quot;language-text&quot;&gt;cookie-session&lt;/code&gt; and is saved into its request header.&lt;/li&gt;
&lt;li&gt;After PassportJS Google OAuth is finished and verified, it is sent to &lt;code class=&quot;language-text&quot;&gt;http://localhost:7000/auth/google/callback&lt;/code&gt; where you then redirect back to the client.&lt;/li&gt;
&lt;li&gt;Nothing gets sent back to client.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The problem I kept facing was that after Google OAuth is finished and verified, I couldn’t send anything back to the client side. In order to go from &lt;code class=&quot;language-text&quot;&gt;http://localhost:7000/auth/google/callback&lt;/code&gt; to &lt;code class=&quot;language-text&quot;&gt;http://localhost:3000&lt;/code&gt;, you have to do a &lt;code class=&quot;language-text&quot;&gt;res.redirect(#your_url)&lt;/code&gt;. However, there’s no way (that I currently know how) to both redirect and send data unless it’s through the URI query. However, passing a token/cookie/session through a URI query is unsecure. So, because nothing was sent back, I’m unable to create any routes with authorization or authentication unless I have to go through Google OAuth every time I need to access one of those points.&lt;/p&gt;
&lt;p&gt;All in all, the main problem I faced was being unable to send either a cookie/session/token after Google OAuth verification. In the next part, hopefully I will have solved how to either send a cookie/session/token securely to be able to use Google OAuth.&lt;/p&gt;</content:encoded></item></channel></rss>